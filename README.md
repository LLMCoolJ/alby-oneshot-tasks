# Lightning Wallet Demo

A React application demonstrating 8 Bitcoin Lightning Network payment scenarios using the [Alby SDK](https://github.com/getAlby/alby-js-sdk). Built entirely by Claude Code using a spec-driven workflow with the orchestrator/sub-agent pattern.

**Live demo wallets:** [faucet.nwc.dev](https://faucet.nwc.dev) (no setup required)

## Rebuild From Scratch

This repo includes a `START-HERE` git tag that marks the point before any code was generated. Everything after it was built by Claude Code. To rebuild the entire application yourself:

### 1. Clone and reset to the starting point

```bash
git clone <repo-url>
cd <repo>
git checkout -b my-build START-HERE
```

This gives you a clean working tree with only the specs, skills, and prompts — no generated code.

### 2. Configure `CLAUDE_CODE_TMPDIR`

Update `.claude/settings.json` and `.claude/settings.local.json` with your actual project path:

```jsonc
// .claude/settings.json and .claude/settings.local.json
{
  "env": {
    "CLAUDE_CODE_TMPDIR": "/path/to/your/clone",
    // ...
  }
}
```

`settings.local.json` also contains git permission rules with the project path — update those too.

Optionally set it in your shell profile:

```bash
# ~/.bashrc or ~/.zshrc
export CLAUDE_CODE_TMPDIR="/path/to/your/clone"
```

### 3. Generate the PREAMBLE

Open Claude Code in the project directory and run:

```
/implement-spec init
```

This spawns parallel sub-agents to extract structured data from every spec and generates `specs/PREAMBLE.md` — the context document that every sub-agent receives during implementation. **This step is required before implementing any specs.**

### 4. Run the build

You have two options:

**Option A: Build specs one at a time**

```
/implement-spec 01
/implement-spec 02
/implement-spec 03
...
```

This lets you inspect results between specs, make adjustments, or restart from a specific point. Specs must be built in order (each depends on earlier ones).

**Option B: Build all specs at once**

```
@IMPLEMENT.md
```

This triggers the full sequential build of all 15 specs. Each spec is implemented, tested, reviewed, and committed automatically via the `/implement-spec` skill.

In either case, if context is lost mid-spec, just re-run `/implement-spec NN` — the manifest at `progress/spec-NN/manifest.json` tracks phase-level state, so it picks up exactly where it left off.

---

## Table of Contents

- [Rebuild From Scratch](#rebuild-from-scratch)
- [How This Repo Was Built](#how-this-repo-was-built)
  - [Starting Point](#starting-point)
  - [Step 1: Write the PRD](#step-1-write-the-prd)
  - [Step 2: Generate Specs from the PRD](#step-2-generate-specs-from-the-prd)
  - [Step 3: Align Specs with ALIGN_SPEC_PROMPT.md](#step-3-align-specs-with-align_spec_promptmd)
  - [Step 4: Generate PREAMBLE.md](#step-4-generate-preamblemd)
  - [Step 5: Implement All Specs](#step-5-implement-all-specs)
- [The IMPLEMENT.md Numbering Bug](#the-implementmd-numbering-bug)
- [The Orchestrator/Sub-Agent Pattern](#the-orchestratorsub-agent-pattern)
- [What is MEMORY.md?](#what-is-memorymd)
- [The Alby Agent Skill](#the-alby-agent-skill)
- [The Generated Application](#the-generated-application)
  - [Architecture](#architecture)
  - [The 8 Scenarios](#the-8-scenarios)
  - [Tech Stack](#tech-stack)
  - [Project Structure](#project-structure)
- [Running the Application](#running-the-application)
- [Testing](#testing)
- [Build Pipeline Summary](#build-pipeline-summary)

---

## How This Repo Was Built

This entire application was generated by Claude Code using a multi-phase workflow. The repo includes a `START-HERE` git tag that marks the starting point — everything before it is scaffolding (the specs, skills, and prompts); everything after it is generated code.

### Starting Point

At the `START-HERE` tag, the repo contained:

- `PRD.md` — the product requirements document
- `specs/` — 17 specification files (00-overview through 16-testing-strategy)
- `specs/ALIGNMENT_TRACKER.md` — tracking cross-spec consistency
- `ALIGN_SPEC_PROMPT.md` — the prompt used to align specs
- `IMPLEMENT.md` — the orchestration prompt for implementing all specs
- `.claude/skills/implement-spec/` — the skill definition for implementing a single spec
- `.claude/skills/alby-agent-skill/` — Lightning/NWC documentation skill
- `progress/` — empty manifest directories for tracking implementation phases

No application code existed yet. The 18 commits between `START-HERE` and `done` are all generated.

### Step 1: Write the PRD

The process starts with `PRD.md`, a product requirements document describing:

- 8 "Alice & Bob" Lightning payment scenarios
- The tech stack (React, TypeScript, Vite, Tailwind, Express, Alby SDK)
- UI component descriptions (sidebar, wallet cards, transaction log)
- SDK method signatures for each scenario
- Testnet setup instructions

The PRD was written manually to define what the application should do.

### Step 2: Generate Specs from the PRD

The PRD was broken into 17 implementation specs in the `specs/` directory:

| # | Spec | Purpose |
|---|------|---------|
| 00 | overview | Architecture reference (no code) |
| 01 | project-setup | Vite, TypeScript, Tailwind config |
| 02 | process-management | Systemd services, dev scripts |
| 03 | shared-types | TypeScript types, constants, type guards |
| 04 | shared-components | UI primitives (Button, Card, Badge, etc.) |
| 05 | wallet-context | React Context, hooks, wallet components |
| 06 | layout | App shell, sidebar, routing |
| 07-14 | scenarios 1-8 | Each payment scenario page |
| 15 | backend | Express API server |
| 16 | testing-strategy | Test infrastructure, mocks, CI |

Each spec defines exactly what files to create, what they export, what tests to write, and what dependencies they have on earlier specs. Specs are ordered so each one only imports from specs with a lower number.

### Step 3: Align Specs with ALIGN_SPEC_PROMPT.md

Before implementation, specs were cross-checked for consistency using `ALIGN_SPEC_PROMPT.md`. This prompt:

1. Reads all reference specs (types, components, hooks, layout, backend)
2. Reads the target scenario spec
3. Checks for inconsistencies: type names, component props, hook signatures, route paths, file structure patterns
4. Fixes inconsistencies (preferring to fix the scenario spec over the reference)
5. Tracks progress in `specs/ALIGNMENT_TRACKER.md`

The alignment prompt is run repeatedly. Each run processes one spec, updating its status from `pending` → `fixing` → `no fixes`. The process uses the `/alby-agent-skill` to verify SDK method signatures are correct.

**To re-run alignment:**

1. Set any spec status to `pending` in `specs/ALIGNMENT_TRACKER.md`
2. Run the prompt from `ALIGN_SPEC_PROMPT.md` in Claude Code
3. Repeat until all specs show `no fixes`

### Step 4: Generate PREAMBLE.md

Before implementation can begin, the system needs a context document that summarizes all specs for the sub-agents. This is generated with:

```
/implement-spec init
```

This spawns parallel sub-agents (one per spec) that extract structured data: file lists, exports, routes, coding standards, mock patterns, and test commands. The results are merged into `specs/PREAMBLE.md`, which contains:

- Tech stack summary
- Reference file tables (what each spec creates)
- Scenario route tables
- Import availability rules (spec N can only import from specs < N)
- Coding standards extracted from all specs
- Test command reference
- Mock patterns for NWC, Lightning Tools, and hooks

Every sub-agent receives PREAMBLE.md as its first context, ensuring consistent implementation across all specs.

### Step 5: Implement All Specs

Implementation is orchestrated by `IMPLEMENT.md`, which runs `/implement-spec NN` for each spec in sequence. Each spec goes through a 9-phase workflow managed by spawning fresh sub-agents (via Claude Code's `Task` tool) for each phase:

| Phase | Task | Description |
|-------|------|-------------|
| 1 | Implement | Create all files defined in the spec |
| 2 | Verify | Check implementation matches spec exactly |
| 3 | Unit Tests | Write unit tests |
| 4 | E2E Tests | Write end-to-end tests |
| 5 | Run Tests | Execute typecheck + unit + E2E |
| 6 | Fix | Fix any test failures |
| 7 | Screenshots | Review E2E screenshots for visual issues |
| 8 | Code Review | Code quality and refactoring check |
| 9 | Commit | Git commit and tag |

**Feedback loops:**
- Phase 2 fails → back to Phase 1 (max 3 iterations)
- Phase 5 fails → Phase 6 fixes → Phase 5 re-runs (max 5 iterations)
- Phase 7 issues → Phase 6 fixes → Phase 5 re-runs
- Phase 8 needs refactor → Phase 6 fixes → Phase 5 re-runs (max 3 iterations)

Each phase writes a JSON artifact to `progress/spec-NN/` and updates `manifest.json`. If context is lost mid-spec, re-running `/implement-spec NN` reads the manifest and resumes from the last completed phase.

Progress across specs is tracked using Claude Code's task system (`TaskCreate`/`TaskUpdate`). Each spec gets a task, marked `in_progress` when starting and `completed` when done. The task list survives `/compact` operations, providing a persistent view of overall build progress.

---

## The IMPLEMENT.md Numbering Bug

`IMPLEMENT.md` lists specs numbered 01-15, but the mapping is wrong — it labels spec 02 as "Shared Types" when the actual file is `02-process-management.md`, and so on. The spec filenames in the `specs/` directory are the source of truth:

| IMPLEMENT.md says | Actual spec file |
|-------------------|-----------------|
| 01: Project Setup | `01-project-setup.md` |
| 02: Shared Types | `02-process-management.md` |
| 03: Shared Components | `03-shared-types.md` |
| ... | (shifted by one) |

The `/implement-spec` skill itself uses the spec file path from the manifest, not the IMPLEMENT.md label, so the bug has no impact on the generated code.

---

## The Orchestrator/Sub-Agent Pattern

This repo uses Claude Code's `Task` tool to implement a clean orchestrator/sub-agent architecture — no agent teams involved.

### How It Works

The orchestrator (the main Claude Code session) manages the entire build. For each phase of each spec, it:

1. Reads the manifest to determine the current phase
2. Spawns a fresh `Task` agent (sub-agent) with a focused prompt
3. The sub-agent does its work (implement, test, review, etc.) and returns a JSON artifact
4. The orchestrator writes the artifact to disk and updates the manifest
5. Moves to the next phase

Each sub-agent gets a self-contained prompt that includes:
- The full `specs/PREAMBLE.md` (project context)
- The phase-specific template with filled placeholders
- Relevant artifacts from previous phases

Sub-agents are **stateless** — they receive all context as a prompt parameter and return a JSON result. They don't share memory or communicate with each other. The orchestrator is the only entity that maintains state, and it does so entirely through the filesystem (`progress/spec-NN/manifest.json`).

### Why This Works Well

- **No message delivery issues** — Sub-agents receive their full context upfront, unlike team-based approaches where message delivery can degrade over long sessions
- **Resumable** — All state is on disk. If the session crashes, re-running `/implement-spec NN` picks up exactly where it left off
- **Fresh context per phase** — Each sub-agent starts clean, avoiding context pollution from earlier phases
- **Simple coordination** — The orchestrator reads/writes a single manifest file. No inter-agent messaging protocol needed

### Progress Tracking

The `IMPLEMENT.md` outer loop uses Claude Code's task system for spec-level tracking:

```
TaskCreate("Implement spec 08 - scenario-3-notifications")
TaskUpdate(taskId, status: "in_progress")
/implement-spec 08
TaskUpdate(taskId, status: "completed")
/compact
```

The task list survives `/compact` operations, so after context compaction the orchestrator can check `TaskList` to find the next pending spec.

---

## What is MEMORY.md?

Claude Code has a persistent memory system at `~/.claude/projects/<project>/memory/MEMORY.md`. This file survives across conversation sessions and context compactions. The agent reads it at the start of every conversation and updates it as it learns.

During the build of this project, the agent used MEMORY.md to record implementation progress, patterns it discovered, and workarounds for recurring issues. This allowed it to adapt its behavior over time — for example, recording that certain specs passed clean on the first try, or that specific test patterns needed attention.

MEMORY.md is project-scoped, so each project gets its own memory. If you rebuild from `START-HERE`, your Claude Code session will develop its own memory based on the issues it encounters.

---

## The Alby Agent Skill

The `.claude/skills/alby-agent-skill/` directory provides Claude Code with authoritative documentation for Bitcoin Lightning integration. When invoked with `/alby-agent-skill`, it loads:

- **NWC Client docs** — `@getalby/sdk` API for wallet operations (pay, invoice, balance, notifications, hold invoices)
- **Lightning Tools docs** — `@getalby/lightning-tools` for BOLT-11 parsing, LNURL, fiat conversion
- **Bitcoin Connect docs** — UI components for wallet connection
- **TypeScript definitions** — Complete `.d.ts` files for type-safe implementation
- **Testing patterns** — Mock factories, test wallet setup

This skill was used in two places:
1. **During spec alignment** — to verify that SDK method signatures in the specs matched the actual library API
2. **During implementation** — specs that use Lightning features (03+) trigger `/alby-agent-skill` to give the sub-agent accurate API knowledge

Without this skill, the agent would have had to guess at SDK method signatures or make web requests for documentation. The skill provides offline, version-pinned docs that match the exact library versions in `package.json`.

---

## The Generated Application

### Architecture

```
+-----------------------------------------------------+
|                    React App (:5741)                  |
+--------------+--------------------------------------+
|   Sidebar    |         Scenario Page                 |
|              |  +------------------------------+     |
|  Scenario 1  |  |  Alice's Wallet    Bob's Wallet |  |
|  Scenario 2  |  |  +-----------+    +-----------+ |  |
|  Scenario 3  |  |  |  Balance  |    |  Balance  | |  |
|  ...         |  |  |  Actions  |    |  Actions  | |  |
|  Scenario 8  |  |  +-----------+    +-----------+ |  |
|              |  |  Transaction Log / Status        |  |
|              |  +------------------------------+     |
+--------------+--------------------------------------+
|              Express API (:3741)                      |
+-----------------------------------------------------+
|                                                       |
|          Nostr Wallet Connect (NIP-47)                |
|              <-> WebSocket relay <->                  |
|          Lightning Network (testnet)                  |
+-------------------------------------------------------+
```

Two wallets (Alice and Bob) connect via NWC URLs from [faucet.nwc.dev](https://faucet.nwc.dev). All communication with the Lightning Network goes through Nostr relays using the NIP-47 protocol — no direct node access required.

### The 8 Scenarios

| # | Scenario | What it demonstrates |
|---|----------|---------------------|
| 1 | **Simple Payment** | Bob creates a BOLT-11 invoice, Alice pays it. The fundamental Lightning flow. |
| 2 | **Lightning Address** | Alice pays `bob@domain.com` — system resolves LNURL, fetches invoice, pays automatically. |
| 3 | **Notifications** | Bob subscribes to real-time payment notifications. Alice sends payments, Bob's UI updates live. |
| 4 | **Hold Invoice** | Escrow-style payment: Alice pays, funds are held until Bob settles (claims) or cancels (refunds). |
| 5 | **Proof of Payment** | Alice pays and gets a preimage. Demonstrates `hash(preimage) === payment_hash` verification. |
| 6 | **Transaction History** | Both wallets query and display their past transactions with filtering. |
| 7 | **Nostr Zap** | Alice "zaps" Bob's Nostr note — social tipping with proper Nostr event tags. |
| 8 | **Fiat Conversion** | Display amounts in both sats and fiat (USD, EUR, GBP). Real-time conversion as you type. |

### Tech Stack

| Layer | Technology |
|-------|-----------|
| Frontend | React 18 + TypeScript 5.6 + Vite 6 |
| Styling | Tailwind CSS 3.4 |
| State | React Context + useReducer |
| Routing | React Router DOM 7 |
| Lightning | @getalby/sdk 7.0 (NWC) + @getalby/lightning-tools 6.1 |
| Backend | Express 4.21 |
| Unit Tests | Vitest 2.1 + Testing Library |
| E2E Tests | Playwright 1.48 (Chromium, Firefox, Mobile Safari) |

### Project Structure

```
src/
├── main.tsx                         # Entry point
├── App.tsx                          # Router with lazy-loaded pages
├── index.css                        # Tailwind + custom components
│
├── types/index.ts                   # ~250 types, constants, type guards
├── lib/crypto.ts                    # Preimage/hash crypto utilities
│
├── context/WalletContext.tsx         # Dual-wallet state (Alice & Bob)
│
├── hooks/                           # 14 custom hooks
│   ├── useWallet.ts                 #   Get wallet state
│   ├── useWalletActions.ts          #   Connect/disconnect
│   ├── useNWCClient.ts              #   Raw NWC client access
│   ├── useBalance.ts                #   Balance polling
│   ├── useInvoice.ts                #   Create invoices
│   ├── usePayment.ts                #   Pay invoices
│   ├── useBudget.ts                 #   Spending budget
│   ├── useFiatRate.ts               #   BTC/fiat rates
│   ├── useTransactionLog.ts         #   Event log management
│   ├── useLightningAddressPayment.ts #  Pay Lightning addresses
│   ├── useNotifications.ts          #   NWC notification subscriptions
│   ├── useHoldInvoice.ts            #   Hold invoice lifecycle
│   ├── useTransactions.ts           #   Transaction history
│   └── useZap.ts                    #   Nostr zap functionality
│
├── components/
│   ├── ui/                          # Shared primitives
│   │   ├── Button.tsx               #   4 variants, 3 sizes
│   │   ├── Input.tsx                #   With forwardRef
│   │   ├── Card.tsx                 #   Container with shadow
│   │   ├── Badge.tsx                #   Status indicators
│   │   ├── Spinner.tsx              #   Loading animation
│   │   ├── QRCode.tsx               #   QR code display
│   │   └── CopyButton.tsx           #   Copy-to-clipboard
│   ├── wallet/                      # Wallet display components
│   │   ├── WalletCard.tsx
│   │   ├── BalanceDisplay.tsx
│   │   └── WalletConnect.tsx
│   ├── layout/                      # App shell
│   │   ├── Layout.tsx
│   │   ├── Sidebar.tsx
│   │   └── ScenarioPage.tsx
│   └── transaction/
│       └── TransactionLog.tsx
│
├── pages/                           # 8 scenario pages
│   ├── 1-SimplePayment/
│   ├── 2-LightningAddress/
│   ├── 3-Notifications/
│   ├── 4-HoldInvoice/
│   ├── 5-ProofOfPayment/
│   ├── 6-TransactionHistory/
│   ├── 7-NostrZap/
│   └── 8-FiatConversion/

server/
├── index.ts                         # Express app + middleware
├── config.ts                        # Environment config
└── routes/demo.ts                   # Demo wallet endpoints

tests/
├── setup.ts                         # Global mocks (crypto, WebSocket)
├── unit/                            # Unit tests
├── e2e/                             # E2E tests
├── mocks/                           # NWC, Lightning Tools, crypto mocks
└── utils/                           # Test wallet helpers

progress/                            # Implementation tracking
├── spec-01/ through spec-15/       # Phase artifacts + manifests
```

---

## Running the Application

### Prerequisites

- Node.js 18+
- npm

### Install

```bash
npm install
```

### Development

```bash
npm run dev
```

This starts both:
- **Frontend** (Vite) at `http://localhost:5741`
- **Backend** (Express) at `http://localhost:3741`

### Connect Wallets

1. Go to [faucet.nwc.dev](https://faucet.nwc.dev) and create two test wallets
2. Copy the NWC connection strings
3. Paste them into the Alice and Bob wallet connection inputs in the app
4. Start exploring the 8 scenarios

### Other Commands

| Command | Purpose |
|---------|---------|
| `npm run dev:client` | Frontend only |
| `npm run dev:server` | Backend only |
| `npm run build` | TypeScript check + Vite production build |
| `npm run preview` | Preview the production build |
| `npm run typecheck` | TypeScript type checking |
| `npm run lint` | ESLint |

---

## Testing

```bash
# Unit tests
npm test

# Unit tests with UI dashboard
npm run test:ui

# Coverage report
npm run test:coverage

# E2E tests — requires dev server running
npm run dev &
npm run test:e2e
```

E2E tests run across 3 browsers: Chromium, Firefox, and Mobile Safari (iPhone 13 emulation).

**Test structure:**
- Unit tests: `tests/unit/**/*.test.{ts,tsx}`
- E2E tests: `tests/e2e/**/*.spec.ts`

---

## Build Pipeline Summary

The complete pipeline from zero to working application:

```
PRD.md (manual)
  |
specs/00-16 (generated from PRD)
  |
ALIGNMENT_TRACKER.md <- ALIGN_SPEC_PROMPT.md (cross-spec consistency)
  |
/implement-spec init -> specs/PREAMBLE.md (sub-agent context document)
  |
@IMPLEMENT.md -> /implement-spec 01..15
  |
  For each spec (orchestrator spawns Task sub-agents per phase):
    Phase 1: Sub-agent implements code
    Phase 2: Sub-agent verifies against spec
    Phase 3: Sub-agent writes unit tests
    Phase 4: Sub-agent writes E2E tests
    Phase 5: Sub-agent runs all tests
    Phase 6: Sub-agent fixes failures (loop)
    Phase 7: Sub-agent reviews screenshots
    Phase 8: Sub-agent does code review
    Phase 9: Sub-agent commits + tags
    Orchestrator: Reports results, moves to next spec
  |
15 specs implemented, tested, committed, and tagged
```

**Total: 17 specs (15 implemented), Task sub-agents per phase, ~100 files of application code.**
